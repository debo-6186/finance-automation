"""
Agent2Agent (A2A) Protocol Server Implementation.
Provides base functionality for agents to expose A2A endpoints.
"""
import json
import uuid
from datetime import datetime
from typing import Any, Dict, List, Optional, Union
from enum import Enum

from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse, StreamingResponse
from pydantic import BaseModel, Field
import structlog

logger = structlog.get_logger(__name__)

class TaskState(str, Enum):
    """Task states as defined by A2A protocol."""
    SUBMITTED = "submitted"
    WORKING = "working"
    INPUT_REQUIRED = "input-required"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELED = "canceled"

class MessageRole(str, Enum):
    """Message roles as defined by A2A protocol."""
    USER = "user"
    AGENT = "agent"

class PartType(str, Enum):
    """Part types for message content."""
    TEXT = "text"
    FILE = "file"
    DATA = "data"

class Part(BaseModel):
    """A part represents content within a message or artifact."""
    type: PartType
    content: Union[str, Dict[str, Any]]
    metadata: Optional[Dict[str, Any]] = None

class Message(BaseModel):
    """A message in the A2A conversation."""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    role: MessageRole
    parts: List[Part]
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    parent_id: Optional[str] = None

class Artifact(BaseModel):
    """An artifact represents output generated by an agent."""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    type: str
    parts: List[Part]
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    metadata: Optional[Dict[str, Any]] = None

class Task(BaseModel):
    """A task represents a unit of work in the A2A protocol."""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    state: TaskState = TaskState.SUBMITTED
    messages: List[Message] = []
    artifacts: List[Artifact] = []
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    error: Optional[str] = None

class SendTaskRequest(BaseModel):
    """Request to send a task to an agent."""
    message: Message
    task_id: Optional[str] = None

class SendTaskResponse(BaseModel):
    """Response from sending a task."""
    task: Task

class AgentCard(BaseModel):
    """Agent Card for capability discovery."""
    name: str
    description: str
    version: str
    capabilities: List[str]
    skills: Dict[str, Dict[str, Any]]
    endpoint: str
    authentication: Optional[Dict[str, Any]] = None

class A2AServer:
    """
    Base class for implementing A2A protocol servers.
    Each agent should inherit from this class and implement the process_task method.
    """
    
    def __init__(self, agent_name: str, agent_description: str, capabilities: List[str], 
                 skills: Dict[str, Dict[str, Any]], port: int = 8000):
        self.agent_name = agent_name
        self.agent_description = agent_description
        self.capabilities = capabilities
        self.skills = skills
        self.port = port
        self.app = FastAPI(title=f"{agent_name} A2A Server")
        self.tasks: Dict[str, Task] = {}
        
        # Setup routes
        self._setup_routes()
        
        logger.info(f"A2A Server initialized for {agent_name}")
    
    def _setup_routes(self):
        """Setup FastAPI routes for A2A protocol."""
        
        @self.app.get("/.well-known/agent.json")
        async def get_agent_card():
            """Return the agent card for capability discovery."""
            return self._get_agent_card()
        
        @self.app.post("/tasks/send", response_model=SendTaskResponse)
        async def send_task(request: SendTaskRequest):
            """Handle task submission."""
            try:
                task_id = request.task_id or str(uuid.uuid4())
                
                # Create or update task
                if task_id in self.tasks:
                    task = self.tasks[task_id]
                    task.messages.append(request.message)
                else:
                    task = Task(
                        id=task_id,
                        messages=[request.message],
                        state=TaskState.WORKING
                    )
                    self.tasks[task_id] = task
                
                # Process the task
                await self._process_task(task)
                
                return SendTaskResponse(task=task)
                
            except Exception as e:
                logger.error(f"Error processing task: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/tasks/{task_id}")
        async def get_task(task_id: str):
            """Get task status and results."""
            if task_id not in self.tasks:
                raise HTTPException(status_code=404, detail="Task not found")
            return self.tasks[task_id]
        
        @self.app.post("/tasks/{task_id}/cancel")
        async def cancel_task(task_id: str):
            """Cancel a running task."""
            if task_id not in self.tasks:
                raise HTTPException(status_code=404, detail="Task not found")
            
            task = self.tasks[task_id]
            task.state = TaskState.CANCELED
            task.updated_at = datetime.utcnow()
            
            return {"status": "canceled"}
    
    def _get_agent_card(self) -> AgentCard:
        """Generate the agent card for this agent."""
        return AgentCard(
            name=self.agent_name,
            description=self.agent_description,
            version="1.0.0",
            capabilities=self.capabilities,
            skills=self.skills,
            endpoint=f"http://localhost:{self.port}",
            authentication=None  # Could be extended for authentication
        )
    
    async def _process_task(self, task: Task):
        """
        Process a task. This method should be overridden by subclasses.
        
        Args:
            task: The task to process
        """
        try:
            task.state = TaskState.WORKING
            task.updated_at = datetime.utcnow()
            
            # Call the agent-specific processing logic
            result = await self.process_task(task)
            
            # Handle the result
            if result:
                if isinstance(result, str):
                    # Simple text response
                    response_message = Message(
                        role=MessageRole.AGENT,
                        parts=[Part(type=PartType.TEXT, content=result)]
                    )
                    task.messages.append(response_message)
                elif isinstance(result, dict):
                    # Structured data response
                    response_message = Message(
                        role=MessageRole.AGENT,
                        parts=[Part(type=PartType.DATA, content=result)]
                    )
                    task.messages.append(response_message)
                elif isinstance(result, Artifact):
                    # Artifact response
                    task.artifacts.append(result)
            
            task.state = TaskState.COMPLETED
            task.updated_at = datetime.utcnow()
            
        except Exception as e:
            logger.error(f"Error processing task {task.id}: {e}")
            task.state = TaskState.FAILED
            task.error = str(e)
            task.updated_at = datetime.utcnow()
    
    async def process_task(self, task: Task) -> Union[str, Dict[str, Any], Artifact, None]:
        """
        Override this method in subclasses to implement agent-specific logic.
        
        Args:
            task: The task to process
            
        Returns:
            The result of processing the task
        """
        raise NotImplementedError("Subclasses must implement process_task method")
    
    def run(self, host: str = "0.0.0.0"):
        """Run the A2A server."""
        import uvicorn
        logger.info(f"Starting {self.agent_name} A2A Server on {host}:{self.port}")
        uvicorn.run(self.app, host=host, port=self.port)

def create_text_part(content: str) -> Part:
    """Helper function to create a text part."""
    return Part(type=PartType.TEXT, content=content)

def create_data_part(content: Dict[str, Any]) -> Part:
    """Helper function to create a data part."""
    return Part(type=PartType.DATA, content=content)

def create_artifact(artifact_type: str, parts: List[Part], metadata: Optional[Dict[str, Any]] = None) -> Artifact:
    """Helper function to create an artifact."""
    return Artifact(type=artifact_type, parts=parts, metadata=metadata) 